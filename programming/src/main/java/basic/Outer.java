package basic;

/**
 * 静态内部类
 * @author matthew_wu
 * @since 2019-08-08 18:24
 */
public class Outer {
    // 定义一个实例变量和一个静态变量
    private int a;

    private static int b;

    // 定义一个静态方法和一个非静态方法
    public static void say() {

    }

    public void test() {
        //在外部类中调用内部类的属性和方法
        Outer.Inner.c = 1; // 可以通过静态内部类的全类名来调用静态内部类的静态属性（外部类名.静态内部类名.属性）
        Outer.Inner.go();  // 可以通过静态内部类的全类名来调用静态内部类的静态方法（外部类名.静态内部类名.方法）
        // Outer.Inner.walk(); //不能通过类静态内部类的全类名来调用内部类的非静态属性和方法
        Inner inner = new Inner();  //可以通过创建内部类实例来调用静态内部类的非静态属性和方法
        inner.d = 1;
        inner.walk();
    }

    // 静态内部类
    public static class Inner {
        // 在静态内部类中定义一个静态变量和一个实例变量
        static int c;
        int d;
        // 定义一个匿名代码块和一个静态代码块
        {
        }
        static {
        }
        // 定义一个静态方法和一个普通方法
        public static void go() {

        }
        public void walk() {
            // 在静态内部类中调用外部类的属性和方法
            int f = b; //可以直接调用外部类的静态变量
            say();   //可以直接调用外部类的静态方法
            // int e = a; 直接调用外部类的非静态属性出错编译出错
            // test(); 直接调用外部类的非静态方法时编译出错
            Outer outer = new Outer();
            int e = outer.a; //可以通过创建外部类实例来调用外部类的非静态属性
            outer.test(); //可以通过创建外部类实例来调用外部类的非静态方法
        }
    }
}

/*
    将某个内部类定义为静态类，跟将其他类定义为静态类的方法基本相同，引用规则也基本一致。不过其细节方面仍然有很大的不同。具体来说，主要有如下几个地方要引起各位程序开发人员的注意。

    一是静态成员(包括静态变量与静态成员)的定义。一般情况下，如果一个内部类不是被定义成静态内部类，那么在定义成员变量或者成员方法的时候，是不能够被定义成静态成员变量与静态成员方法的。
    也就是说，在非静态内部类中不可以声明静态成员。如现在在一个student类中定义了一个内部类age，如果没有将这个类利用static关键字修饰，即没有定义为静态类，
    那么在这个内部类中如果要利用static关键字来修饰某个成员方法或者成员变量是不允许的。在编译的时候就通不过。故程序开发人员需要注意，只有将某个内部类修饰为静态类，
    然后才能够在这个类中定义静态的成员变量与成员方法。这是静态内部类都有的一个特性。也正是因为这个原因，有时候少了这个静态的内部类，很多工作就无法完成。
    或者说要绕一个大圈才能够实现某个用户的需求。这也是静态的内部类之所以要存在的一个重要原因。

    二是在成员的引用上，有比较大的限制。一般的非静态内部类，可以随意的访问外部类中的成员变量与成员方法。
    即使这些成员方法被修饰为private(私有的成员变量或者方法)，其非静态内部类都可以随意的访问。则是非静态内部类的特权。
    因为在其他类中是无法访问被定义为私有的成员变量或则方法。但是如果一个内部类被定义为静态的，那么在银用外部类的成员方法或则成员变量的时候，
    就会有诸多的限制。如不能够从静态内部类的对象中访问外部类的非静态成员(包括成员变量与成员方法)。这是什么意思呢?
    如果在外部类中定义了两个变量，一个是非静态的变量，一个是静态的变量。那么在静态内部类中，无论在成员方法内部还是在其他地方，
    都只能够引用外部类中的静态的变量，而不能够访问非静态的变量。在静态内部类中，可以定义静态的方法(也只有在静态的内部类中可以定义静态的方法)，
    在静态方法中引用外部类的成员。但是无论在内部类的什么地方引用，有一个共同点，即都只能够引用外部类中的静态成员方法或者成员变量。
    对于那些非静态的成员变量与成员方法，在静态内部类中是无法访问的。这就是静态内部类的最大使用限制。在普通的非静态内部类中是没有这个限制的。
    也正是这个原因，决定了静态内部类只应用在一些特定的场合。其应用范围远远没有像非静态的内部类那样广泛。

    三是在创建静态内部类时不需要将静态内部类的实例绑定在外部类的实例上。

    通常情况下，在一个类中创建成员内部类的时候，有一个强制性的规定，即内部类的实例一定要绑定在外部类的实例中。
    也就是说，在创建内部类之前要先在外部类中要利用new关键字来创建这个内部类的对象。如此的话如果从外部类中初始化一个内部类对象，那么内部类对象就会绑定在外部类对象上。
    也就是说，普通非静态内部类的对象是依附在外部类对象之中的。但是，如果成员开发人员创建的时静态内部类，那么这就又另当别论了。
    通常情况下，程序员在定义静态内部类的时候，是不需要定义绑定在外部类的实例上的。
    也就是说，要在一个外部类中定义一个静态的内部类，不需要利用关键字new来创建内部类的实例。即在创建静态类内部对象时，
    不需要其外部类的对象。具体为什么会这样，一般程序开发人员不需要了解这么深入，只需要记住有这个规则即可。在定义静态内部类的时候，千万不要犯画蛇添足的错误。

    从以上的分析中可以看出，静态内部类与非静态的内部类还是有很大的不同的。一般程序开发人员可以这么理解，
    非晶态的内部类对象隐式地在外部类中保存了一个引用，指向创建它的外部类对象。不管怎么理解，程序开发人员都需要牢记静态内部类与非静态内部类的差异。
    如是否可以创建静态的成员方法与成员变量(静态内部类可以创建静态的成员而非静态的内部类不可以)、
    对于访问外部类的成员的限制(静态内部类只可以访问外部类中的静态成员变量与成员方法而非静态的内部类即可以访问静态的也可以访问非静态的外部类成员方法与成员变量)。
    这两个差异是静态内部类与非静态外部类最大的差异，也是静态内部类之所以存在的原因。了解了这个差异之后，程序开发人员还需要知道，在什么情况下该使用静态内部类。
    如在程序测试的时候，为了避免在各个Java源文件中书写主方法的代码，可以将主方法写入到静态内部类中，以减少代码的书写量，让代码更加的简洁。

    总之，静态内部类在Java语言中是一个很特殊的类，跟普通的静态类以及非静态的内部类都有很大的差异。
    作为程序开发人员，必须要知道他们之间的差异，并在实际工作中在合适的地方采用合适的类。不过总的来说，静态内部类的使用频率并不是很高。
    但是在有一些场合，如果没有这个内部静态类的话，可能会起到事倍功半的反面效果


    静态内部类：具有静态变量和内部类的特点；
    静态变量的优点：一般静态变量都是公用的、全局的，程序一启动就会在内存开辟一块空间，存放它们。静态的不必实例化就能直接使用。
    内部类的优点：实现更好的封装，和使用外部类的数据；
    作用的话只能说你需要用到静态内部类的优点时，就可以去定义一个静态内部类；

    需要了解2个概念：内部类和静态修饰符static
    1）首先，用内部类是因为内部类与所在外部类有一定的关系，往往只有该外部类调用此内部类。所以没有必要专门用一个Java文件存放这个类。
    2）静态都是用来修饰类的内部成员的。比如静态方法，静态成员变量，静态常量。它唯一的作用就是随着类的加载（而不是随着对象的产生）而产生，以致可以用类名+静态成员名直接获得。
    这样静态内部类就可以理解了，因为这个类没有必要单独存放一个文件，它一般来说只被所在外部类使用。并且它可以直接被用 外部类名+内部类名 获得。

    1.如果内部类不会引用到外部类东西的话，强烈建议使用静态内部类，因为这样更节省资源，减少内部类其中的一个指向外部类的引用。
    2.这个静态内部类，不需要在外部引用，只为当前类提供服务。  封装的完整性。
    3.还有静态内部类只能访问外部类的静态属性和方法，而且静态内部类还可以有静态数据，静态方法或者又一个静态内部类，这些是非静态内部类所没有的。


    静态内部类，就是定义在外部类的成员位置上，之所以用静态修饰，就是因为内部类中都是共享数据，没有特有数据，定义成静态的，
    就可以直接用类名访问，不用在堆内存中创建对象。比较节省空间。

    静态内部类是 static 修饰的内部类，这种内部类的特点是：
    1、 静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问
    2、 如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；
    如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员
    3、 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类();
*/
